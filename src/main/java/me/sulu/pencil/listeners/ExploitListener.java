package me.sulu.pencil.listeners;

import discord4j.common.util.Snowflake;
import discord4j.core.event.domain.interaction.ButtonInteractionEvent;
import discord4j.core.object.component.ActionRow;
import discord4j.core.object.component.Button;
import discord4j.core.object.entity.User;
import discord4j.core.object.reaction.ReactionEmoji;
import discord4j.core.spec.EmbedCreateSpec;
import discord4j.core.spec.InteractionApplicationCommandCallbackSpec;
import discord4j.discordjson.json.ImmutableStartThreadRequest;
import discord4j.rest.util.Color;
import me.sulu.pencil.Pencil;
import me.sulu.pencil.util.StringUtil;
import org.checkerframework.checker.nullness.qual.Nullable;
import reactor.core.publisher.Mono;
import reactor.util.Logger;
import reactor.util.Loggers;

public class ExploitListener {
  private static final Logger logger = Loggers.getLogger(ExploitListener.class);
  private static final ReactionEmoji githubEmoji = ReactionEmoji.custom(Snowflake.of(822054840389206056L), "github", false);
  private final Pencil pencil;

  public ExploitListener(final Pencil pencil) {
    this.pencil = pencil;
    this.pencil.client().on(ButtonInteractionEvent.class, this::on).subscribe();
  }

  private Mono<Void> on(ButtonInteractionEvent event) {
    return switch (event.getCustomId()) {
      case "exploit-report" -> sendExploitConfirmation(event);
      case "exploit-confirm" -> handleExploitReport(event);
      default -> Mono.empty();
    };
  }

  private Mono<Void> handleExploitReport(ButtonInteractionEvent event) {
    if (event.getInteraction().getGuildId().isEmpty()) return this.fail(event, null);

    final User author = event.getInteraction().getUser();

    return this.pencil.client().rest().getChannelService()
      .startThreadWithoutMessage(event.getInteraction().getChannelId().asLong(), ImmutableStartThreadRequest.of(StringUtil.randomName(), 10080))
      .flatMap(threadData -> this.pencil.client().rest().getChannelService()
        .addThreadMember(threadData.id().asLong(), author.getId().asLong())
        .then(event.reply("Thank you for starting your exploit report. Please put details of your exploit in <#" + threadData.id().asString() + ">").withEphemeral(true))
        .then(this.pencil.client().rest().getChannelById(Snowflake
            .of(this.pencil.config().guild(event.getInteraction().getGuildId().get()).channels().exploitReport()))
          .createMessage("Exploit report created in <#%s> by %s (%s)".formatted(threadData.id().asString(), author.getMention(), author.getTag()))
        )
      )
      .then()
      .onErrorResume(t -> this.fail(event, t));
  }

  private Mono<Void> sendExploitConfirmation(ButtonInteractionEvent event) {
    return event.reply(InteractionApplicationCommandCallbackSpec.builder()
      .ephemeral(true)
      .addEmbed(EmbedCreateSpec.builder()
        .title("Are you sure you would like to open an exploit report?")
        .description("Exploit reports are only for serious, gamebreaking and exploitable issues that are better reported privately. " +
          "For non-exploitable or well-known bugs, please create an issue on our public issue tracker. " +
          "If you are having trouble with your server or think you have found a bug but are not sure, ask in <#289587909051416579>.")
        .footer("To cancel your report, click \"Dismiss message\".", "https://static.sulu.me/images/logos/paper/64.webp")
        .color(Color.RUST)
        .build()
      )
      .addComponent(ActionRow.of(
        Button.link("https://github.com/PaperMC/Paper/issues/new", githubEmoji, "Public Issue Tracker"),
        Button.danger("exploit-confirm", "Confirm Report")
      ))
      .build());
  }

  private Mono<Void> fail(ButtonInteractionEvent event, @Nullable Throwable t) {
    logger.warn("Failed to create exploit report channel", t);
    return event.reply("Unable to automatically create a private channel. Please contact a moderator directly.").withEphemeral(true);
  }
}
