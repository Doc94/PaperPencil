package me.sulu.pencil.listeners;

import discord4j.common.util.Snowflake;
import discord4j.core.event.domain.interaction.ButtonInteractionEvent;
import discord4j.core.object.component.ActionRow;
import discord4j.core.object.component.Button;
import discord4j.core.object.entity.User;
import discord4j.core.spec.EmbedCreateSpec;
import discord4j.core.spec.InteractionApplicationCommandCallbackSpec;
import discord4j.discordjson.json.ImmutableStartThreadRequest;
import discord4j.rest.util.Color;
import me.sulu.pencil.Pencil;
import me.sulu.pencil.util.Emojis;
import me.sulu.pencil.util.RateLimiter;
import me.sulu.pencil.util.StringUtil;
import org.checkerframework.checker.nullness.qual.Nullable;
import reactor.core.Disposable;
import reactor.core.publisher.Mono;
import reactor.util.Logger;
import reactor.util.Loggers;

import java.time.Duration;

public class ExploitListener extends Listener {
  private static final Logger LOGGER = Loggers.getLogger(ExploitListener.class);
  private final RateLimiter<Snowflake> limit = new RateLimiter<>(Duration.ofMinutes(5), 1);

  public ExploitListener(Pencil pencil) {
    super(pencil);
  }

  private Mono<Void> on(ButtonInteractionEvent event) {
    if (event.getInteraction().getGuildId().isEmpty()
      || this.pencil().config().guild(event.getInteraction().getGuildId().get()).channels().exploitReport() == 0L) {
      return Mono.empty();
    }

    return switch (event.getCustomId()) {
      case "exploit-report" -> sendExploitConfirmation(event);
      case "exploit-confirm" -> handleExploitReport(event);
      default -> Mono.empty();
    };
  }

  private Mono<Void> handleExploitReport(ButtonInteractionEvent event) {
    final User author = event.getInteraction().getUser();
    if (limit.limit(author.getId())) {
      return event.reply("To prevent abuse, you may only attempt to create one exploit report every five minutes! Please try again later or contact the moderators via /modmail.").withEphemeral(true);
    }
    return this.pencil().client().rest().getChannelService()
      .startThreadWithoutMessage(event.getInteraction().getChannelId().asLong(), ImmutableStartThreadRequest.of(StringUtil.randomName(), 10080))
      .flatMap(threadData -> this.pencil().client().rest().getChannelService()
        .addThreadMember(threadData.id().asLong(), author.getId().asLong())
        .then(event.reply("Thank you for starting your exploit report. Please put details of your exploit in <#" + threadData.id().asString() + ">").withEphemeral(true))
        .then(this.pencil().client().rest().getChannelById(Snowflake
            .of(this.pencil().config().guild(event.getInteraction().getGuildId().get()).channels().exploitReport()))
          .createMessage("Exploit report created in <#%s> by %s (%s)".formatted(threadData.id().asString(), author.getMention(), author.getTag()))
        )
      )
      .then()
      .onErrorResume(t -> this.fail(event, t));
  }

  private Mono<Void> sendExploitConfirmation(ButtonInteractionEvent event) {
    return event.reply(InteractionApplicationCommandCallbackSpec.builder()
      .ephemeral(true)
      .addEmbed(EmbedCreateSpec.builder()
        .title("Are you sure you would like to open an exploit report?")
        .description("Exploit reports are only for serious, gamebreaking and exploitable issues that are better reported privately. " +
          "For non-exploitable or well-known bugs, please create an issue on our public issue tracker. " +
          "If you are having trouble with your server or think you have found a bug but are not sure, ask in <#289587909051416579>.")
        .footer("To cancel your report, click \"Dismiss message\".", "https://static.sulu.me/images/logos/paper/64.webp")
        .color(Color.RUST)
        .build()
      )
      .addComponent(ActionRow.of(
        Button.link("https://github.com/PaperMC/Paper/issues/new", Emojis.GITHUB, "Public Issue Tracker"),
        Button.danger("exploit-confirm", "Confirm Report")
      ))
      .build());
  }

  private Mono<Void> fail(ButtonInteractionEvent event, @Nullable Throwable t) {
    LOGGER.warn("Failed to create exploit report channel", t);
    return event.reply("Unable to automatically create a private channel. Please contact a moderator directly.").withEphemeral(true);
  }

  @Override
  public Disposable start() {
    return this.on(ButtonInteractionEvent.class, this::on).subscribe();
  }
}
